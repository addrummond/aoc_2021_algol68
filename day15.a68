MODE COORD = STRUCT (
  INT x, y
);

OP = = (COORD c1, COORD c2) BOOL: (x OF c1 = x OF c2) AND (y OF c1 = y OF c2);
OP /= = (COORD c1, COORD c2) BOOL: NOT (c1 = c2);

PROC in range = (INT width, height, COORD c) BOOL: (x OF c) > 0 AND (x OF c) <= width AND (y OF c) > 0 AND (y OF c) <= height;

# assumes source is 1,1 and dest is N,M in NxM grid #
PROC dijkstra := (INT width, INT height, PROC (INT, INT) INT get) REF []COORD:
BEGIN
  REF []COORD q := HEAP [1:width * height]COORD;
  REF [,]BOOL in q := HEAP [width, height]BOOL;
  INT q n := 0;

  REF [,]INT dist := HEAP [width, height]INT;
  REF [,]COORD prev := HEAP [width, height]COORD;

  REF FLEX []COORD path := HEAP FLEX [1:8]COORD;
  INT n path elems := 0;

  COORD undefined coord = (-max int, -max int);

  FOR i FROM 1 TO width DO
    FOR j FROM 1 TO height DO
      dist[i,j] := max int;
      prev[i,j] := undefined coord;
      q n +:= 1;
      q[q n] := (i, j);
      in q[i, j] := TRUE
    OD
  OD;

  dist[1,1] := 0;

  WHILE q n > 0 DO
    INT min dist := max int;
    COORD u := undefined coord;
    INT ui := -1;
    FOR i FROM 1 TO q n DO
      COORD c = q[i];
      IF dist[x OF c, y OF c] < min dist THEN
        min dist := dist[x OF c, y OF c];
        u := c;
        ui := i
      FI;
    OD;

    q[ui:q n -1] := q[ui+1:q n];
    q n -:= 1;
    in q[x OF u, y OF u] := FALSE;

    IF (x OF u) = width AND (y OF u) = height THEN
      WHILE u /= undefined coord DO
        n path elems +:= 1;
        IF n path elems > UPB path THEN
          REF FLEX []COORD new path = HEAP FLEX[1:2*UPB path]COORD;
          new path[:UPB path] := path;
          path := new path
        FI;
        path[n path elems] := u;
        u := prev[x OF u, y OF u]
      OD;
      GO TO out
    FI;

    []COORD neighbors = ((x OF u, (y OF u) + 1), ((x OF u) + 1, y OF u), (x OF u, (y OF u) - 1), ((x OF u) -1, y OF u));
    FOR i FROM LWB neighbors TO UPB neighbors DO
      COORD v := neighbors[i];

      IF IF in range(width, height, v) THEN in q[x OF v, y OF v] ELSE FALSE FI THEN
        INT alt := dist[x OF u, y OF u] + get(x OF v, y OF v);
        IF alt < dist[x OF v, y OF v] THEN
          dist[x OF v, y OF v] := alt;
          prev[x OF v, y OF v] := u
        FI
      FI
    OD
  OD;

out:
  REF FLEX []COORD(path) := path[1:n path elems];
  path
END;

PROC read grid = (REF FILE in, REF BOOL finished reading) REF [,]INT:
BEGIN
  REF FLEX []REF []INT lines := HEAP FLEX [1:8]REF []INT;
  INT n lines := 0;

  WHILE
    NOT finished reading
  DO
    STRING s;
    get(in, (s, newline));
    REF []INT ns := HEAP [1:UPB s]INT;
    FOR i FROM LWB s TO UPB s DO
      ns[i] := ABS(s[i]) - ABS("0")
    OD;

    n lines +:= 1;
    IF n lines > UPB lines THEN
      REF FLEX []REF []INT new lines = HEAP FLEX [2*UPB lines]REF []INT;
      new lines[:UPB lines] := lines;
      lines := new lines
    FI;
    lines[n lines] := ns
  OD;

  REF [,]INT grid = HEAP [UPB lines[1], n lines]INT;
  FOR i FROM LWB lines[1] TO UPB lines[1] DO
    FOR j FROM LWB lines TO n lines DO
      grid[i, j] := lines[j][i]
    OD
  OD;

  grid
END;

PROC debug print grid and path = (REF [,]INT grid, REF []COORD path) VOID:
BEGIN
  FOR y FROM 1 TO 2 UPB grid DO
    FOR x FROM 1 TO UPB grid DO
      BOOL in path := FALSE;
      FOR i FROM LWB path TO UPB path DO
        IF x OF path[i] = x AND y OF path[i] = y THEN
          in path := TRUE;
          GO TO out
        FI
      OD;
      out:
      IF in path THEN
        print(("*"))
      ELSE
        printf(($d$, grid[x,y]))
      FI
    OD;
    print(newline)
  OD
END;

PROC main := VOID:
BEGIN
  FILE in;

  open(in, "data/data15.txt", stand in channel);
  BOOL finished reading := FALSE;
  on logical file end (in, (REF FILE f) BOOL: finished reading := TRUE);
  on format error (in, (REF FILE f) BOOL: finished reading := TRUE);

  REF [,]INT grid = read grid(in, finished reading);
  REF []COORD part 1 path = dijkstra(
    UPB grid,
    2 UPB grid,
    (INT x, INT y) INT: grid[x,y]
  );

  INT part 1 tot := 0;
  FOR i FROM LWB part 1 path TO UPB part 1 path DO
    part 1 tot +:= grid[x OF part 1 path[i], y OF part 1 path[i]]
  OD;
  part 1 tot -:= grid[1,1]; # start position is ignored #
  printf(($"Part 1: lowest total risk of any path = ", g(0)l$, part 1 tot));

  PROC part 2 get = (INT x, INT y) INT:
  BEGIN
    INT extra := ((x-1) OVER UPB grid) + ((y-1) OVER 2 UPB grid);
    INT v := extra + grid[((x-1) MOD UPB grid) + 1, ((y-1) MOD 2 UPB grid) + 1];
    ((v - 1) MOD 9) + 1
  END;

  REF []COORD part 2 path = dijkstra(
    UPB grid * 5,
    (2 UPB grid) * 5,
    part 2 get
  );

  INT part 2 tot := 0;
  FOR i FROM LWB part 2 path TO UPB part 2 path DO
    part 2 tot +:= part 2 get(x OF part 2 path[i], y OF part 2 path[i])
  OD;
  part 2 tot -:= grid[1,1]; # start position is ignored #
  printf(($"Part 2: lowest total risk of any path = ", g(0)l$, part 2 tot))
END;

main
