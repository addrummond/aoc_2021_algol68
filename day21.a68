PROC part 1 = VOID:
BEGIN
  INT winning score = 1000;

  INT p1pos := 4;
  INT p2pos := 3;
  INT p1score := 0;
  INT p2score := 0;
  INT die := 1;
  INT n rolls := 0;

  WHILE p1score < winning score AND p2score < winning score DO
    INT rolls := die * 3 + 3;
    n rolls +:= 3;
    die +:= 3;
    p1pos := ((p1pos - 1 + rolls) MOD 10) + 1;

    rolls := die * 3 + 3;
    die +:= 3;
    p2pos := ((p2pos - 1 + rolls) MOD 10) + 1;

    p1score +:= p1pos;
    IF p1score < winning score THEN
      n rolls +:= 3;
      p2score +:= p2pos
    FI
  OD;

  INT winning;
  INT losing;
  INT r =
    IF p1score < p2score THEN
      winning := p2score;
      losing := p1score;
      p1score * n rolls
    ELSE
      losing := p2score;
      winning := p1score;
      p2score * n rolls
    FI;

  printf(($"Part 1: winning score = ", g(0), "; losing score = ", g(0), "; rolls * losing score = ", g(0)l$, winning, losing, r))
END;

PROC part 2 = VOID:
BEGIN
  INT winning score = 21;
  INT p1start = 4;
  INT p2start = 3;

  #
    The idea here is that we keep track of the number of universes in a given state,
    where a state is composed of
    
      1) The position of player 1
      2) The position of player 2
      3) The score of player 1
      4) The score of player 2
      5) The player whose turn it is next
    
    We can just loop through each of the states (which isn't a vast number) and do some arithmetic.
    We switch alternately between two copies of the state table (first array index) to avoid interference.
  #

  REF [,,,,,]LONG INT states := LOC [1:2,1:10,1:10,1:winning score+1,1:winning score+1,1:2]LONG INT;
  FOR ab FROM 1 TO 2 DO
    FOR pos1 FROM 2 LWB states TO 2 UPB states DO
      FOR pos2 FROM 3 LWB states TO 3 UPB states DO
        FOR s1 FROM 4 LWB states TO 4 UPB states DO
          FOR s2 FROM 5 LWB states TO 5 UPB states DO
            FOR pturn FROM 1 TO 2 DO
              states[ab,pos1,pos2,s1,s2,pturn] := 0
            OD
          OD
        OD
      OD
    OD
  OD;

  INT ab := 1;
  states[ab,p1start,p2start,0+1,0+1,1] := 1;

  BOOL continue := TRUE;
  INT n loops := 0;
  WHILE continue DO
    n loops +:= 1;
    continue := FALSE;

    INT nextab := (ab MOD 2)+1;

    FOR pos1 FROM 2 LWB states TO 2 UPB states DO
      FOR pos2 FROM 3 LWB states TO 3 UPB states DO
        FOR s1 FROM 4 LWB states TO 4 UPB states - 1 DO # -1 to ignore states that already have a winner #
          FOR s2 FROM 5 LWB states TO 5 UPB states - 1 DO # -1 to ignore states that already have a winner #
            FOR pturn FROM 1 TO 2 DO
              states[nextab,pos1,pos2,s1,s2,pturn] := 0
            OD
          OD
        OD
      OD
    OD;

    FOR pos1 FROM 2 LWB states TO 2 UPB states DO
      FOR pos2 FROM 3 LWB states TO 3 UPB states DO
        FOR s1 FROM 4 LWB states TO 4 UPB states - 1 DO # -1 to ignore states that already have a winner #
          FOR s2 FROM 5 LWB states TO 5 UPB states - 1 DO # -1 to ignore states that already have a winner #
            FOR pturn FROM 1 TO 2 DO
              IF states[ab,pos1,pos2,s1,s2,pturn] > 0 THEN
                continue := TRUE;

                INT nextpturn := (pturn MOD 2) + 1;

                FOR roll1 FROM 1 TO 3 DO
                  FOR roll2 FROM 1 TO 3 DO
                    FOR roll3 FROM 1 TO 3 DO
                      IF pturn = 1 THEN
                        INT newpos := ((pos1 - 1 + roll1 + roll2 + roll3) MOD 10) + 1;
                        INT news := s1 - 1 + newpos;
                        IF news > winning score THEN
                          news := winning score
                        FI;
                        states[nextab,newpos,pos2,news+1,s2,2] +:= states[ab,pos1,pos2,s1,s2,pturn]
                      ELSE
                        INT newpos := ((pos2 - 1 + roll1 + roll2 + roll3) MOD 10) + 1;
                        INT news := s2 - 1 + newpos;
                        IF news > winning score THEN
                          news := winning score
                        FI;
                        states[nextab,pos1,newpos,s1,news+1,1] +:= states[ab,pos1,pos2,s1,s2,pturn]
                      FI
                    OD
                  OD
                OD
              FI
            OD
          OD
        OD
      OD
    OD;

    IF continue THEN
      ab := nextab
    FI
  OD;

  LONG INT p1wins := 0;
  FOR pos1 FROM 2 LWB states TO 2 UPB states DO
    FOR pos2 FROM 3 LWB states TO 3 UPB states DO
      FOR s2 FROM 5 LWB states TO 5 UPB states DO
        p1wins +:= states[ab,pos1,pos2,winning score+1,s2,2]
      OD
    OD
  OD;

  LONG INT p2wins := 0;
  FOR pos1 FROM 2 LWB states TO 2 UPB states DO
    FOR pos2 FROM 3 LWB states TO 3 UPB states DO
      FOR s1 FROM 4 LWB states TO 4 UPB states DO
        # Player 2's winning states will tbe in the other table (hence ab MOD 2)+1) #
        p2wins +:= states[(ab MOD 2)+1,pos1,pos2,s1,winning score+1,1]
      OD
    OD
  OD;

  printf(($"Part 2: player 1 wins in ", g(0), " universes; player 2 wins in ", g(0), " universes"$, p1wins, p2wins));
  print(newline);
  IF p1wins > p2wins THEN
    print(("Player 1 won in the most universes", newline))
  ELIF p2wins > p1wins THEN
    print(("Player 2 won in the most universes", newline))
  ELSE
    print(("Players 1 and 2 won in the same number of universes", newline))
  FI
END;

part 1;
part 2
